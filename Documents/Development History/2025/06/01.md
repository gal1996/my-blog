とりあえずlocalで動くところまで来たので、ここまでのvibe-codingで進めてきたブログの開発の結果をドキュメントがてら残してみる。

まず、この開発を通してやりたかったことは大体以下かなな？
- vibe-codingでマジで自分でコード書かずにAIに書かせたらどういうものが出来上がるのか？
- それなりの規模感になるまでやってみて、設計が整っている方がAIが作るものは精度が良いのか？
  - これが一番みたいところ。
- AIを講師として技術の勉強ができるか？
  - フロントやらなさすぎなので自分のフロントの勉強兼ねてみた

設計が整っている方が、AIが作るものの精度が高くなるか？が一番試したかったので、次の手順を取ってみた
- まずはgeminiを使って、会話しながらとりあえず動くものを設計とかは気にせず作ってみた(←イマココ)
- これ以降は、geminiを使うのをやめてcursorに寄せて開発をより進めていく。
- で、汚いブランチと綺麗なブランチを用意して、結構本当にガッツリとしたシステムになるくらいに機能を足していく。
- 両方のブランチで同じプロンプトで、機能を足していってどのくらい精度に差が出るか比較する。

vibe-coding前提なので、エラーメッセージも全部geminiに食わせて解決してる

こんな感じでやってみる。
ここまでやったことはgeminiにとりあえずまとめさせてみた。

## 1. アプリケーションの基盤構築

まずは、モダンなフロントエンドの土台を作りました。

* **フロントエンド**: `React (TypeScript)` を採用し、宣言的なUIを構築。
* **開発環境**: 高速なビルドツールである `Vite` と、効率的なパッケージマネージャーの `pnpm` を導入。
* **初期UI**: ブログのヘッダーなど、シンプルなReactコンポーネントを作成し、`Props` や `key` プロパティといったReactの基本概念を習得。
* **スタイリング**: `Tailwind CSS` を導入し、ユーティリティクラスを直接JSXに適用することで、効率的かつ統一感のあるデザインを実現。この過程で、JavaScriptのモジュールシステム（CommonJSとES Modules）の衝突に関するトラブルシューティングを経験しました。

---

## 2. 動的な機能とバックエンドの連携

次に、アプリケーションに動的な要素と、データの供給源となるバックエンドを追加しました。

* **ルーティング**: `React Router DOM` を使用し、ブログの複数ページ間のスムーズな遷移（SPA体験）を実現。URLパラメーター (`:id`) を使って個別記事の詳細ページを表示できるようにしました。
* **API連携**: フロントエンドで `useState` と `useEffect` フックを活用し、HTTP `fetch` API を用いて、非同期でバックエンドからブログ記事データを取得・表示するようにしました。
* **バックエンドAPI**: `Next.js の API Routes` を利用して、ダミーデータを提供するシンプルなRESTful APIを構築。全記事取得と個別記事取得のエンドポイントを定義しました。
* **CORS対応**: フロントエンドとバックエンドが異なるポートで動作する際に発生する `CORS（Cross-Origin Resource Sharing）エラー` を、バックエンド側で適切なHTTPヘッダーを設定することで解決しました。また、Next.jsのAPIルートにおける特定のルールや型定義に関するエラーも解決しました。

---

## 3. アプリケーションのコンテナ化

クラウド環境へのデプロイを見据え、アプリケーションをDockerコンテナとしてパッケージ化し、複数のサービスをまとめて管理できるようにしました。

* **Dockerイメージの構築**: フロントエンドとバックエンドそれぞれに `Dockerfile` を作成。軽量な本番イメージを実現するため、`マルチステージビルド` を採用しました。
* **Docker Composeでの統合**: `docker-compose.yml` ファイルを作成し、フロントエンドとバックエンドのサービスを定義。両コンテナの起動・停止、ポートマッピング、サービス間の依存関係を一元管理できるようにしました。
* **コンテナ起動時のトラブルシューティング**: コンテナ内でコマンドが見つからない問題や、サーバーが外部に公開されない問題など、Docker環境特有のランタイムエラーをデバッグし、起動スクリプトやネットワーク設定を修正することで解決しました。これにより、画像表示も含む、よりリアルなブログアプリケーションがコンテナ内で完全に動作するようになりました。
